use anyhow::Result;
use base64::{engine::general_purpose::STANDARD, Engine};

pub fn open_markdown_in_browser(markdown_content: &str) -> Result<()> {
    let html = create_html_document(markdown_content);
    let encoded = STANDARD.encode(html.as_bytes());
    let data_url = format!("data:text/html;charset=utf-8;base64,{}", encoded);

    webbrowser::open(&data_url)?;
    Ok(())
}

fn create_html_document(markdown_content: &str) -> String {
    let html_content = markdown_to_html(markdown_content);

    format!(
        r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weavex Result</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: #0d1117;
            color: #c9d1d9;
        }}
        h1, h2, h3, h4, h5, h6 {{
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #58a6ff;
        }}
        h1 {{ font-size: 2em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }}
        h2 {{ font-size: 1.5em; border-bottom: 1px solid #21262d; padding-bottom: 0.3em; }}
        p {{ margin-bottom: 16px; }}
        a {{
            color: #58a6ff;
            text-decoration: none;
        }}
        a:hover {{
            text-decoration: underline;
        }}
        code {{
            background: #161b22;
            padding: 0.2em 0.4em;
            border-radius: 6px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 85%;
        }}
        pre {{
            background: #161b22;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            line-height: 1.45;
        }}
        pre code {{
            background: none;
            padding: 0;
        }}
        ul, ol {{
            padding-left: 2em;
            margin-bottom: 16px;
        }}
        li {{
            margin-bottom: 0.25em;
        }}
        blockquote {{
            padding: 0 1em;
            color: #8b949e;
            border-left: 0.25em solid #30363d;
            margin: 0 0 16px 0;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 16px;
        }}
        th, td {{
            border: 1px solid #30363d;
            padding: 6px 13px;
        }}
        th {{
            font-weight: 600;
            background: #161b22;
        }}
        hr {{
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #30363d;
            border: 0;
        }}
        .meta {{
            color: #8b949e;
            font-size: 0.9em;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #21262d;
        }}
    </style>
</head>
<body>
    <div class="meta">ðŸ§µ Generated by Weavex</div>
    {}
</body>
</html>"#,
        html_content
    )
}

fn markdown_to_html(markdown: &str) -> String {
    let mut html = String::new();
    let mut in_code_block = false;
    let mut in_list = false;

    for line in markdown.lines() {
        if line.starts_with("```") {
            if in_code_block {
                html.push_str("</code></pre>\n");
                in_code_block = false;
            } else {
                html.push_str("<pre><code>");
                in_code_block = true;
            }
            continue;
        }

        if in_code_block {
            html.push_str(&escape_html(line));
            html.push('\n');
            continue;
        }

        if let Some(stripped) = line.strip_prefix("# ") {
            html.push_str(&format!("<h1>{}</h1>\n", escape_html(stripped)));
        } else if let Some(stripped) = line.strip_prefix("## ") {
            html.push_str(&format!("<h2>{}</h2>\n", escape_html(stripped)));
        } else if let Some(stripped) = line.strip_prefix("### ") {
            html.push_str(&format!("<h3>{}</h3>\n", escape_html(stripped)));
        } else if let Some(stripped) = line.strip_prefix("#### ") {
            html.push_str(&format!("<h4>{}</h4>\n", escape_html(stripped)));
        } else if line.starts_with("- ") || line.starts_with("* ") {
            if !in_list {
                html.push_str("<ul>\n");
                in_list = true;
            }
            html.push_str(&format!("<li>{}</li>\n", process_inline(&line[2..])));
        } else if line.trim().is_empty() {
            if in_list {
                html.push_str("</ul>\n");
                in_list = false;
            }
            html.push_str("<p></p>\n");
        } else {
            if in_list {
                html.push_str("</ul>\n");
                in_list = false;
            }
            html.push_str(&format!("<p>{}</p>\n", process_inline(line)));
        }
    }

    if in_code_block {
        html.push_str("</code></pre>\n");
    }
    if in_list {
        html.push_str("</ul>\n");
    }

    html
}

fn process_inline(text: &str) -> String {
    let mut result = escape_html(text);

    result = regex_replace(&result, r"\*\*(.+?)\*\*", "<strong>$1</strong>");
    result = regex_replace(&result, r"\*(.+?)\*", "<em>$1</em>");
    result = regex_replace(&result, r"`(.+?)`", "<code>$1</code>");
    result = regex_replace(&result, r"\[(.+?)\]\((.+?)\)", r#"<a href="$2">$1</a>"#);

    result
}

fn regex_replace(text: &str, pattern: &str, replacement: &str) -> String {
    let re = regex::Regex::new(pattern).unwrap();
    re.replace_all(text, replacement).to_string()
}

fn escape_html(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_html() {
        assert_eq!(escape_html("<script>"), "&lt;script&gt;");
        assert_eq!(escape_html("a & b"), "a &amp; b");
    }
}
